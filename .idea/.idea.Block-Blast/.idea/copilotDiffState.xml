<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/BlockDragHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/BlockDragHandler.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using BlockBlast.Data;&#10;using DG.Tweening;&#10;&#10;namespace BlockBlast.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Xử lý việc drag và drop block lên board&#10;    /// &lt;/summary&gt;&#10;    public class BlockDragHandler : MonoBehaviour&#10;    {&#10;        public event Action&lt;Block, Vector2Int&gt; OnBlockPlacedSuccessfully;&#10;&#10;        [SerializeField] private BoardManager boardManager;&#10;        [SerializeField] private GameConfig config;&#10;&#10;        private Block currentDraggingBlock;&#10;        private Camera mainCamera;&#10;        private bool isProcessingPlacement = false;&#10;&#10;        private void Awake()&#10;        {&#10;            mainCamera = Camera.main;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            DOTween.Kill(this);&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (isProcessingPlacement)&#10;                return;&#10;&#10;            // Tìm block đang được drag&#10;            if (currentDraggingBlock == null)&#10;            {&#10;                CheckForBlockDrag();&#10;            }&#10;&#10;            if (currentDraggingBlock != null &amp;&amp; currentDraggingBlock.IsDragging)&#10;            {&#10;                HandleDragging();&#10;            }&#10;        }&#10;&#10;        private void CheckForBlockDrag()&#10;        {&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;                RaycastHit2D hit = Physics2D.Raycast(mousePos, Vector2.zero);&#10;&#10;                if (hit.collider != null)&#10;                {&#10;                    Block block = hit.collider.GetComponent&lt;Block&gt;();&#10;                    if (block != null)&#10;                    {&#10;                        currentDraggingBlock = block;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void HandleDragging()&#10;        {&#10;            if (Input.GetMouseButtonUp(0))&#10;            {&#10;                HandleDrop();&#10;            }&#10;            else&#10;            {&#10;                // Preview vị trí đặt&#10;                Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;                &#10;                // Adjust for block's pivot offset to get accurate grid position&#10;                Vector3 adjustedPos = mousePos - currentDraggingBlock.GetPivotOffset();&#10;                Vector2Int gridPos = boardManager.GetGridPosition(adjustedPos);&#10;&#10;                // Highlight các ô trên board&#10;                bool canPlace = boardManager.CanPlaceBlock(currentDraggingBlock.Shape, gridPos);&#10;                boardManager.HighlightPreview(currentDraggingBlock.Shape, gridPos, canPlace, currentDraggingBlock.StoneSprite);&#10;            }&#10;        }&#10;&#10;        private void HandleDrop()&#10;        {&#10;            if (isProcessingPlacement)&#10;                return;&#10;&#10;            // Clear preview highlight&#10;            boardManager.ClearPreview();&#10;&#10;            Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;            &#10;            // Adjust for block's pivot offset&#10;            Vector3 adjustedPos = mousePos - currentDraggingBlock.GetPivotOffset();&#10;            Vector2Int gridPos = boardManager.GetGridPosition(adjustedPos);&#10;&#10;            if (TryPlaceBlock(currentDraggingBlock, gridPos))&#10;            {&#10;                // Đặt thành công&#10;                isProcessingPlacement = true;&#10;                AnimatePlacement(currentDraggingBlock, gridPos);&#10;            }&#10;            else&#10;            {&#10;                // Đặt thất bại, quay về vị trí ban đầu&#10;                AnimateReturn(currentDraggingBlock);&#10;            }&#10;&#10;            currentDraggingBlock = null;&#10;        }&#10;&#10;        private bool TryPlaceBlock(Block block, Vector2Int position)&#10;        {&#10;            return boardManager.CanPlaceBlock(block.Shape, position);&#10;        }&#10;&#10;        private void AnimatePlacement(Block block, Vector2Int gridPosition)&#10;        {&#10;            Vector3 targetPos = boardManager.GetWorldPosition(gridPosition);&#10;            &#10;            // Adjust for block's pivot offset (block pivot is at center, not bottom-left)&#10;            targetPos += block.GetPivotOffset();&#10;            &#10;            // DOTween animation với bounce effect&#10;            block.transform&#10;                .DOMove(targetPos, config.blockPlacementDuration)&#10;                .SetEase(Ease.OutBack)&#10;                .OnComplete(() =&gt; &#10;                {&#10;                    // Thông báo cho GameManager&#10;                    OnBlockPlacedSuccessfully?.Invoke(block, gridPosition);&#10;                    isProcessingPlacement = false;&#10;                });&#10;        }&#10;&#10;        private void AnimateReturn(Block block)&#10;        {&#10;            Vector3 targetPos = block.OriginalPosition;&#10;            &#10;            // DOTween animation với smooth effect&#10;            Sequence sequence = DOTween.Sequence();&#10;            sequence.Append(block.transform.DOMove(targetPos, config.blockReturnDuration).SetEase(Ease.OutQuad));&#10;            sequence.Join(block.transform.DOScale(block.SizeBlockInitial, config.blockReturnDuration).SetEase(Ease.OutQuad));&#10;            sequence.OnComplete(() =&gt; block.ReturnToOriginalPosition());&#10;        }&#10;&#10;        public void SetBoardManager(BoardManager manager)&#10;        {&#10;            boardManager = manager;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using BlockBlast.Data;&#10;using DG.Tweening;&#10;&#10;namespace BlockBlast.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Xử lý việc drag và drop block lên board&#10;    /// &lt;/summary&gt;&#10;    public class BlockDragHandler : MonoBehaviour&#10;    {&#10;        public event Action&lt;Block, Vector2Int&gt; OnBlockPlacedSuccessfully;&#10;&#10;        [SerializeField] private BoardManager boardManager;&#10;        [SerializeField] private GameConfig config;&#10;&#10;        private Block currentDraggingBlock;&#10;        private Camera mainCamera;&#10;        private bool isProcessingPlacement = false;&#10;&#10;        private void Awake()&#10;        {&#10;            mainCamera = Camera.main;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            DOTween.Kill(this);&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (isProcessingPlacement)&#10;                return;&#10;&#10;            // Tìm block đang được drag&#10;            if (currentDraggingBlock == null)&#10;            {&#10;                CheckForBlockDrag();&#10;            }&#10;&#10;            if (currentDraggingBlock != null &amp;&amp; currentDraggingBlock.IsDragging)&#10;            {&#10;                HandleDragging();&#10;            }&#10;        }&#10;&#10;        private void CheckForBlockDrag()&#10;        {&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;                RaycastHit2D hit = Physics2D.Raycast(mousePos, Vector2.zero);&#10;&#10;                if (hit.collider != null)&#10;                {&#10;                    Block block = hit.collider.GetComponent&lt;Block&gt;();&#10;                    if (block != null)&#10;                    {&#10;                        currentDraggingBlock = block;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void HandleDragging()&#10;        {&#10;            if (Input.GetMouseButtonUp(0))&#10;            {&#10;                HandleDrop();&#10;            }&#10;            else&#10;            {&#10;                // Preview vị trí đặt&#10;                Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;                &#10;                // Adjust for block's pivot offset to get accurate grid position&#10;                Vector3 adjustedPos = mousePos - currentDraggingBlock.GetPivotOffset();&#10;                Vector2Int gridPos = boardManager.GetGridPosition(adjustedPos);&#10;&#10;                // Highlight các ô trên board&#10;                bool canPlace = boardManager.CanPlaceBlock(currentDraggingBlock.Shape, gridPos);&#10;                boardManager.HighlightPreview(currentDraggingBlock.Shape, gridPos, canPlace, currentDraggingBlock.StoneSprite);&#10;            }&#10;        }&#10;&#10;        private void HandleDrop()&#10;        {&#10;            if (isProcessingPlacement)&#10;                return;&#10;&#10;            // Clear preview highlight&#10;            boardManager.ClearPreview();&#10;&#10;            Vector3 mousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);&#10;            &#10;            // Adjust for block's pivot offset&#10;            Vector3 adjustedPos = mousePos - currentDraggingBlock.GetPivotOffset();&#10;            Vector2Int gridPos = boardManager.GetGridPosition(adjustedPos);&#10;&#10;            if (TryPlaceBlock(currentDraggingBlock, gridPos))&#10;            {&#10;                // Đặt thành công&#10;                isProcessingPlacement = true;&#10;                AnimatePlacement(currentDraggingBlock, gridPos);&#10;            }&#10;            else&#10;            {&#10;                // Đặt thất bại, quay về vị trí ban đầu&#10;                AnimateReturn(currentDraggingBlock);&#10;            }&#10;&#10;            currentDraggingBlock = null;&#10;        }&#10;&#10;        private bool TryPlaceBlock(Block block, Vector2Int position)&#10;        {&#10;            return boardManager.CanPlaceBlock(block.Shape, position);&#10;        }&#10;&#10;        private void AnimatePlacement(Block block, Vector2Int gridPosition)&#10;        {&#10;            Vector3 targetPos = boardManager.GetWorldPosition(gridPosition);&#10;            &#10;            // Adjust for block's pivot offset (block pivot is at center, not bottom-left)&#10;            targetPos += block.GetPivotOffset();&#10;            &#10;            // DOTween animation với bounce effect&#10;            block.transform&#10;                .DOMove(targetPos, config.blockPlacementDuration)&#10;                .SetEase(Ease.OutBack)&#10;                .OnComplete(() =&gt; &#10;                {&#10;                    // Thông báo cho GameManager&#10;                    OnBlockPlacedSuccessfully?.Invoke(block, gridPosition);&#10;                    isProcessingPlacement = false;&#10;                });&#10;        }&#10;&#10;        private void AnimateReturn(Block block)&#10;        {&#10;            Vector3 targetPos = block.OriginalPosition;&#10;            &#10;            // DOTween animation với smooth effect&#10;            Sequence sequence = DOTween.Sequence();&#10;            sequence.Append(block.transform.DOMove(targetPos, config.blockReturnDuration).SetEase(Ease.OutQuad));&#10;            sequence.Join(block.transform.DOScale(block.SizeBlockInitial, config.blockReturnDuration).SetEase(Ease.OutQuad));&#10;            sequence.OnComplete(() =&gt; block.ReturnToOriginalPosition());&#10;        }&#10;&#10;        public void SetBoardManager(BoardManager manager)&#10;        {&#10;            boardManager = manager;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/BoardManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/BoardManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using BlockBlast.Data;&#10;using BlockBlast.Effects;&#10;&#10;namespace BlockBlast.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý bảng chơi 8x8&#10;    /// &lt;/summary&gt;&#10;    public class BoardManager : MonoBehaviour&#10;    {&#10;        public event Action&lt;int, int&gt; OnCellFilled;&#10;        public event Action&lt;List&lt;int&gt;&gt; OnRowsCleared;&#10;        public event Action&lt;List&lt;int&gt;&gt; OnColumnsCleared;&#10;&#10;        private GameConfig config;&#10;        private Cell[,] cells;&#10;        private int width;&#10;        private int height;&#10;        private List&lt;Vector2Int&gt; currentPreviewCells = new List&lt;Vector2Int&gt;();&#10;&#10;        [SerializeField] private GameObject cellPrefab;&#10;        [SerializeField] private Transform boardContainer;&#10;        [SerializeField] private GameObject destroyEffectPrefab; // Optional: Cell destroy effect&#10;&#10;        public void Initialize(GameConfig gameConfig)&#10;        {&#10;            config = gameConfig;&#10;            width = config.boardWidth;&#10;            height = config.boardHeight;&#10;            cells = new Cell[width, height];&#10;&#10;            CreateBoard();&#10;        }&#10;&#10;        private void CreateBoard()&#10;        {&#10;            // Tạo visual cho board&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    GameObject cellObj = Instantiate(cellPrefab, boardContainer);&#10;                    cellObj.transform.localPosition = new Vector3(x * config.cellSize, y * config.cellSize, 0);&#10;                    cellObj.name = $&quot;Cell_{x}_{y}&quot;;&#10;&#10;                    Cell cell = cellObj.GetComponent&lt;Cell&gt;();&#10;                    cell.Initialize(x, y, false);&#10;                    cell.SetFilled(false, null, config.cellBackgroundSprite);&#10;                    cells[x, y] = cell;&#10;                }&#10;            }&#10;&#10;            // Center board&#10;            Vector3 offset = new Vector3(&#10;                -width * config.cellSize / 2f + config.cellSize / 2f,&#10;                -height * config.cellSize / 2f + config.cellSize / 2f,&#10;                0&#10;            );&#10;            boardContainer.localPosition = offset;&#10;        }&#10;&#10;        public bool CanPlaceBlock(BlockShape shape, Vector2Int position)&#10;        {&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                // Kiểm tra ngoài board&#10;                if (x &lt; 0 || x &gt;= width || y &lt; 0 || y &gt;= height)&#10;                    return false;&#10;&#10;                // Kiểm tra cell đã được lấp đầy&#10;                if (cells[x, y].IsFilled)&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        public void PlaceBlock(BlockShape shape, Vector2Int position, Sprite stoneSprite)&#10;        {&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                cells[x, y].SetFilled(true, stoneSprite, config.cellBackgroundSprite);&#10;                OnCellFilled?.Invoke(x, y);&#10;            }&#10;        }&#10;&#10;        public (List&lt;int&gt; rows, List&lt;int&gt; columns) CheckAndClearLines()&#10;        {&#10;            List&lt;int&gt; rowsToRemove = new List&lt;int&gt;();&#10;            List&lt;int&gt; columnsToRemove = new List&lt;int&gt;();&#10;&#10;            // Kiểm tra các hàng ngang&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                bool isRowFull = true;&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (!cells[x, y].IsFilled)&#10;                    {&#10;                        isRowFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (isRowFull)&#10;                    rowsToRemove.Add(y);&#10;            }&#10;&#10;            // Kiểm tra các cột dọc&#10;            for (int x = 0; x &lt; width; x++)&#10;            {&#10;                bool isColumnFull = true;&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (!cells[x, y].IsFilled)&#10;                    {&#10;                        isColumnFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (isColumnFull)&#10;                    columnsToRemove.Add(x);&#10;            }&#10;&#10;            // Xóa các ô&#10;            foreach (int row in rowsToRemove)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    SpawnDestroyEffect(x, row);&#10;                    cells[x, row].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;&#10;            foreach (int column in columnsToRemove)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    // Tránh spawn effect 2 lần cho cell nằm ở giao điểm&#10;                    bool alreadyDestroyed = false;&#10;                    foreach (int row in rowsToRemove)&#10;                    {&#10;                        if (y == row)&#10;                        {&#10;                            alreadyDestroyed = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    &#10;                    if (!alreadyDestroyed)&#10;                    {&#10;                        SpawnDestroyEffect(column, y);&#10;                    }&#10;                    &#10;                    cells[column, y].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;&#10;            if (rowsToRemove.Count &gt; 0)&#10;                OnRowsCleared?.Invoke(rowsToRemove);&#10;&#10;            if (columnsToRemove.Count &gt; 0)&#10;                OnColumnsCleared?.Invoke(columnsToRemove);&#10;&#10;            return (rowsToRemove, columnsToRemove);&#10;        }&#10;&#10;        private (List&lt;int&gt; rows, List&lt;int&gt; columns) CheckLinesAfterPlacement(BlockShape shape, Vector2Int position)&#10;        {&#10;            List&lt;int&gt; rowsToRemove = new List&lt;int&gt;();&#10;            List&lt;int&gt; columnsToRemove = new List&lt;int&gt;();&#10;&#10;            // Tạo bản sao tạm thời của board state&#10;            bool[,] tempBoard = new bool[width, height];&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    tempBoard[x, y] = cells[x, y].IsFilled;&#10;                }&#10;            }&#10;&#10;            // Đặt block vào bản sao&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;                if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)&#10;                {&#10;                    tempBoard[x, y] = true;&#10;                }&#10;            }&#10;&#10;            // Kiểm tra các hàng ngang&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                bool isRowFull = true;&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (!tempBoard[x, y])&#10;                    {&#10;                        isRowFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (isRowFull)&#10;                    rowsToRemove.Add(y);&#10;            }&#10;&#10;            // Kiểm tra các cột dọc&#10;            for (int x = 0; x &lt; width; x++)&#10;            {&#10;                bool isColumnFull = true;&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (!tempBoard[x, y])&#10;                    {&#10;                        isColumnFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (isColumnFull)&#10;                    columnsToRemove.Add(x);&#10;            }&#10;&#10;            return (rowsToRemove, columnsToRemove);&#10;        }&#10;&#10;        public bool CanPlaceAnyBlock(List&lt;BlockShape&gt; blocks)&#10;        {&#10;            foreach (BlockShape block in blocks)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    for (int x = 0; x &lt; width; x++)&#10;                    {&#10;                        if (CanPlaceBlock(block, new Vector2Int(x, y)))&#10;                            return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        public Vector3 GetWorldPosition(Vector2Int gridPosition)&#10;        {&#10;            return boardContainer.TransformPoint(new Vector3(&#10;                gridPosition.x * config.cellSize,&#10;                gridPosition.y * config.cellSize,&#10;                0&#10;            ));&#10;        }&#10;&#10;        public Vector2Int GetGridPosition(Vector3 worldPosition)&#10;        {&#10;            Vector3 localPos = boardContainer.InverseTransformPoint(worldPosition);&#10;            int x = Mathf.RoundToInt(localPos.x / config.cellSize);&#10;            int y = Mathf.RoundToInt(localPos.y / config.cellSize);&#10;            return new Vector2Int(x, y);&#10;        }&#10;&#10;        public void ClearBoard()&#10;        {&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    cells[x, y].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public int[,] GetBoardState()&#10;        {&#10;            int[,] state = new int[width, height];&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    state[x, y] = cells[x, y].IsFilled ? 1 : 0;&#10;                }&#10;            }&#10;            return state;&#10;        }&#10;        private void SpawnDestroyEffect(int x, int y)&#10;        {&#10;            if (destroyEffectPrefab != null)&#10;            {&#10;                Vector3 worldPos = GetWorldPosition(new Vector2Int(x, y));&#10;                GameObject effectObj = Instantiate(destroyEffectPrefab, worldPos, Quaternion.identity);&#10;                &#10;                CellDestroyEffect effect = effectObj.GetComponent&lt;CellDestroyEffect&gt;();&#10;                if (effect != null)&#10;                {&#10;                    Sprite stoneSprite = cells[x, y].GetCurrentStoneSprite();&#10;                    effect.PlayEffect(worldPos, stoneSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void LoadBoardState(int[,] state)&#10;        {&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    bool isFilled = state[x, y] == 1;&#10;                    // Khi load, sử dụng sprite mặc định nếu có fill&#10;                    Sprite sprite = isFilled &amp;&amp; config.blockStoneSprites.Length &gt; 0 &#10;                        ? config.blockStoneSprites[0] &#10;                        : null;&#10;                    cells[x, y].SetFilled(isFilled, sprite, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void HighlightPreview(BlockShape shape, Vector2Int position, bool canPlace, Sprite blockSprite)&#10;        {&#10;            // Clear previous preview&#10;            ClearPreview();&#10;&#10;            if (!canPlace)&#10;                return;&#10;&#10;            // Show preview với sprite của block&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                // Chỉ preview nếu nằm trong board&#10;                if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)&#10;                {&#10;                    cells[x, y].ShowPreview(blockSprite, canPlace);&#10;                    currentPreviewCells.Add(new Vector2Int(x, y));&#10;                }&#10;            }&#10;&#10;            // Kiểm tra xem có dòng/cột nào sẽ bị xóa không&#10;            var (rows, columns) = CheckLinesAfterPlacement(shape, position);&#10;&#10;            Debug.Log($&quot;[Preview] Rows to clear: {rows.Count}, Columns to clear: {columns.Count}&quot;);&#10;            if (rows.Count &gt; 0)&#10;                Debug.Log($&quot;[Preview] Rows: {string.Join(&quot;, &quot;, rows)}&quot;);&#10;            if (columns.Count &gt; 0)&#10;                Debug.Log($&quot;[Preview] Columns: {string.Join(&quot;, &quot;, columns)}&quot;);&#10;&#10;            // Bật glow cho các cell trong dòng/cột sẽ bị xóa&#10;            foreach (int row in rows)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (cells[x, row].IsFilled)&#10;                    {&#10;                        Debug.Log($&quot;[Glow] Setting glow ON for cell ({x}, {row})&quot;);&#10;                        cells[x, row].SetGlow(true);&#10;                        cells[x, row].SetPreviewSpriteForFilledCell(blockSprite);&#10;                    }&#10;                }&#10;            }&#10;&#10;            foreach (int column in columns)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (cells[column, y].IsFilled)&#10;                    {&#10;                        Debug.Log($&quot;[Glow] Setting glow ON for cell ({column}, {y})&quot;);&#10;                        cells[column, y].SetGlow(true);&#10;                        cells[column, y].SetPreviewSpriteForFilledCell(blockSprite);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearPreview()&#10;        {&#10;            // Clear preview sprites&#10;            foreach (Vector2Int pos in currentPreviewCells)&#10;            {&#10;                if (pos.x &gt;= 0 &amp;&amp; pos.x &lt; width &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; height)&#10;                {&#10;                    cells[pos.x, pos.y].ClearPreview();&#10;                }&#10;            }&#10;            currentPreviewCells.Clear();&#10;&#10;            // Clear glow và restore sprite trên tất cả cells&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    cells[x, y].ClearPreview(); // Gọi ClearPreview cho tất cả cells&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using BlockBlast.Data;&#10;using BlockBlast.Effects;&#10;&#10;namespace BlockBlast.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý bảng chơi 8x8&#10;    /// &lt;/summary&gt;&#10;    public class BoardManager : MonoBehaviour&#10;    {&#10;        public event Action&lt;int, int&gt; OnCellFilled;&#10;        public event Action&lt;List&lt;int&gt;&gt; OnRowsCleared;&#10;        public event Action&lt;List&lt;int&gt;&gt; OnColumnsCleared;&#10;&#10;        private GameConfig config;&#10;        private Cell[,] cells;&#10;        private int width;&#10;        private int height;&#10;        private List&lt;Vector2Int&gt; currentPreviewCells = new List&lt;Vector2Int&gt;();&#10;&#10;        [SerializeField] private GameObject cellPrefab;&#10;        [SerializeField] private Transform boardContainer;&#10;        [SerializeField] private GameObject destroyEffectPrefab; // Optional: Cell destroy effect&#10;&#10;        public void Initialize(GameConfig gameConfig)&#10;        {&#10;            config = gameConfig;&#10;            width = config.boardWidth;&#10;            height = config.boardHeight;&#10;            cells = new Cell[width, height];&#10;&#10;            CreateBoard();&#10;        }&#10;&#10;        private void CreateBoard()&#10;        {&#10;            // Tạo visual cho board&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    GameObject cellObj = Instantiate(cellPrefab, boardContainer);&#10;                    cellObj.transform.localPosition = new Vector3(x * config.cellSize, y * config.cellSize, 0);&#10;                    cellObj.name = $&quot;Cell_{x}_{y}&quot;;&#10;&#10;                    Cell cell = cellObj.GetComponent&lt;Cell&gt;();&#10;                    cell.Initialize(x, y, false);&#10;                    cell.SetFilled(false, null, config.cellBackgroundSprite);&#10;                    cells[x, y] = cell;&#10;                }&#10;            }&#10;&#10;            // Center board&#10;            Vector3 offset = new Vector3(&#10;                -width * config.cellSize / 2f + config.cellSize / 2f,&#10;                -height * config.cellSize / 2f + config.cellSize / 2f,&#10;                0&#10;            );&#10;            boardContainer.localPosition = offset;&#10;        }&#10;&#10;        public bool CanPlaceBlock(BlockShape shape, Vector2Int position)&#10;        {&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                // Kiểm tra ngoài board&#10;                if (x &lt; 0 || x &gt;= width || y &lt; 0 || y &gt;= height)&#10;                    return false;&#10;&#10;                // Kiểm tra cell đã được lấp đầy&#10;                if (cells[x, y].IsFilled)&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        public void PlaceBlock(BlockShape shape, Vector2Int position, Sprite stoneSprite)&#10;        {&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                cells[x, y].SetFilled(true, stoneSprite, config.cellBackgroundSprite);&#10;                OnCellFilled?.Invoke(x, y);&#10;            }&#10;        }&#10;&#10;        public (List&lt;int&gt; rows, List&lt;int&gt; columns) CheckAndClearLines()&#10;        {&#10;            List&lt;int&gt; rowsToRemove = new List&lt;int&gt;();&#10;            List&lt;int&gt; columnsToRemove = new List&lt;int&gt;();&#10;&#10;            // Kiểm tra các hàng ngang&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                bool isRowFull = true;&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (!cells[x, y].IsFilled)&#10;                    {&#10;                        isRowFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (isRowFull)&#10;                    rowsToRemove.Add(y);&#10;            }&#10;&#10;            // Kiểm tra các cột dọc&#10;            for (int x = 0; x &lt; width; x++)&#10;            {&#10;                bool isColumnFull = true;&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (!cells[x, y].IsFilled)&#10;                    {&#10;                        isColumnFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (isColumnFull)&#10;                    columnsToRemove.Add(x);&#10;            }&#10;&#10;            // Xóa các ô&#10;            foreach (int row in rowsToRemove)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    SpawnDestroyEffect(x, row);&#10;                    cells[x, row].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;&#10;            foreach (int column in columnsToRemove)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    // Tránh spawn effect 2 lần cho cell nằm ở giao điểm&#10;                    bool alreadyDestroyed = false;&#10;                    foreach (int row in rowsToRemove)&#10;                    {&#10;                        if (y == row)&#10;                        {&#10;                            alreadyDestroyed = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    &#10;                    if (!alreadyDestroyed)&#10;                    {&#10;                        SpawnDestroyEffect(column, y);&#10;                    }&#10;                    &#10;                    cells[column, y].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;&#10;            if (rowsToRemove.Count &gt; 0)&#10;                OnRowsCleared?.Invoke(rowsToRemove);&#10;&#10;            if (columnsToRemove.Count &gt; 0)&#10;                OnColumnsCleared?.Invoke(columnsToRemove);&#10;&#10;            return (rowsToRemove, columnsToRemove);&#10;        }&#10;&#10;        private (List&lt;int&gt; rows, List&lt;int&gt; columns) CheckLinesAfterPlacement(BlockShape shape, Vector2Int position)&#10;        {&#10;            List&lt;int&gt; rowsToRemove = new List&lt;int&gt;();&#10;            List&lt;int&gt; columnsToRemove = new List&lt;int&gt;();&#10;&#10;            // Tạo bản sao tạm thời của board state&#10;            bool[,] tempBoard = new bool[width, height];&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    tempBoard[x, y] = cells[x, y].IsFilled;&#10;                }&#10;            }&#10;&#10;            // Đặt block vào bản sao&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;                if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)&#10;                {&#10;                    tempBoard[x, y] = true;&#10;                }&#10;            }&#10;&#10;            // Kiểm tra các hàng ngang&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                bool isRowFull = true;&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (!tempBoard[x, y])&#10;                    {&#10;                        isRowFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (isRowFull)&#10;                    rowsToRemove.Add(y);&#10;            }&#10;&#10;            // Kiểm tra các cột dọc&#10;            for (int x = 0; x &lt; width; x++)&#10;            {&#10;                bool isColumnFull = true;&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (!tempBoard[x, y])&#10;                    {&#10;                        isColumnFull = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (isColumnFull)&#10;                    columnsToRemove.Add(x);&#10;            }&#10;&#10;            return (rowsToRemove, columnsToRemove);&#10;        }&#10;&#10;        public bool CanPlaceAnyBlock(List&lt;BlockShape&gt; blocks)&#10;        {&#10;            foreach (BlockShape block in blocks)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    for (int x = 0; x &lt; width; x++)&#10;                    {&#10;                        if (CanPlaceBlock(block, new Vector2Int(x, y)))&#10;                            return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        public Vector3 GetWorldPosition(Vector2Int gridPosition)&#10;        {&#10;            return boardContainer.TransformPoint(new Vector3(&#10;                gridPosition.x * config.cellSize,&#10;                gridPosition.y * config.cellSize,&#10;                0&#10;            ));&#10;        }&#10;&#10;        public Vector2Int GetGridPosition(Vector3 worldPosition)&#10;        {&#10;            Vector3 localPos = boardContainer.InverseTransformPoint(worldPosition);&#10;            int x = Mathf.RoundToInt(localPos.x / config.cellSize);&#10;            int y = Mathf.RoundToInt(localPos.y / config.cellSize);&#10;            return new Vector2Int(x, y);&#10;        }&#10;&#10;        public void ClearBoard()&#10;        {&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    cells[x, y].SetFilled(false, null, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public int[,] GetBoardState()&#10;        {&#10;            int[,] state = new int[width, height];&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    state[x, y] = cells[x, y].IsFilled ? 1 : 0;&#10;                }&#10;            }&#10;            return state;&#10;        }&#10;        private void SpawnDestroyEffect(int x, int y)&#10;        {&#10;            if (destroyEffectPrefab != null)&#10;            {&#10;                Vector3 worldPos = GetWorldPosition(new Vector2Int(x, y));&#10;                GameObject effectObj = Instantiate(destroyEffectPrefab, worldPos, Quaternion.identity);&#10;                &#10;                CellDestroyEffect effect = effectObj.GetComponent&lt;CellDestroyEffect&gt;();&#10;                if (effect != null)&#10;                {&#10;                    Sprite stoneSprite = cells[x, y].GetCurrentStoneSprite();&#10;                    effect.PlayEffect(worldPos, stoneSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void LoadBoardState(int[,] state)&#10;        {&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    bool isFilled = state[x, y] == 1;&#10;                    // Khi load, sử dụng sprite mặc định nếu có fill&#10;                    Sprite sprite = isFilled &amp;&amp; config.blockStoneSprites.Length &gt; 0 &#10;                        ? config.blockStoneSprites[0] &#10;                        : null;&#10;                    cells[x, y].SetFilled(isFilled, sprite, config.cellBackgroundSprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void HighlightPreview(BlockShape shape, Vector2Int position, bool canPlace, Sprite blockSprite)&#10;        {&#10;            // Clear previous preview&#10;            ClearPreview();&#10;&#10;            if (!canPlace)&#10;                return;&#10;&#10;            // Show preview với sprite của block&#10;            foreach (Vector2Int cell in shape.cells)&#10;            {&#10;                int x = position.x + cell.x;&#10;                int y = position.y + cell.y;&#10;&#10;                // Chỉ preview nếu nằm trong board&#10;                if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)&#10;                {&#10;                    cells[x, y].ShowPreview(blockSprite, canPlace);&#10;                    currentPreviewCells.Add(new Vector2Int(x, y));&#10;                }&#10;            }&#10;&#10;            // Kiểm tra xem có dòng/cột nào sẽ bị xóa không&#10;            var (rows, columns) = CheckLinesAfterPlacement(shape, position);&#10;&#10;            Debug.Log($&quot;[Preview] Rows to clear: {rows.Count}, Columns to clear: {columns.Count}&quot;);&#10;            if (rows.Count &gt; 0)&#10;                Debug.Log($&quot;[Preview] Rows: {string.Join(&quot;, &quot;, rows)}&quot;);&#10;            if (columns.Count &gt; 0)&#10;                Debug.Log($&quot;[Preview] Columns: {string.Join(&quot;, &quot;, columns)}&quot;);&#10;&#10;            // Bật glow cho các cell trong dòng/cột sẽ bị xóa&#10;            foreach (int row in rows)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    if (cells[x, row].IsFilled)&#10;                    {&#10;                        Debug.Log($&quot;[Glow] Setting glow ON for cell ({x}, {row})&quot;);&#10;                        cells[x, row].SetGlow(true);&#10;                        cells[x, row].SetPreviewSpriteForFilledCell(blockSprite);&#10;                    }&#10;                }&#10;            }&#10;&#10;            foreach (int column in columns)&#10;            {&#10;                for (int y = 0; y &lt; height; y++)&#10;                {&#10;                    if (cells[column, y].IsFilled)&#10;                    {&#10;                        Debug.Log($&quot;[Glow] Setting glow ON for cell ({column}, {y})&quot;);&#10;                        cells[column, y].SetGlow(true);&#10;                        cells[column, y].SetPreviewSpriteForFilledCell(blockSprite);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void ClearGlowAndRestoreSprites()&#10;        {&#10;            // Clear glow và restore sprite trên tất cả cells&#10;            for (int y = 0; y &lt; height; y++)&#10;            {&#10;                for (int x = 0; x &lt; width; x++)&#10;                {&#10;                    cells[x, y].ClearPreview(); // Gọi ClearPreview cho tất cả cells&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearPreview()&#10;        {&#10;            // Clear preview sprites&#10;            foreach (Vector2Int pos in currentPreviewCells)&#10;            {&#10;                if (pos.x &gt;= 0 &amp;&amp; pos.x &lt; width &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; height)&#10;                {&#10;                    cells[pos.x, pos.y].ClearPreview();&#10;                }&#10;            }&#10;            currentPreviewCells.Clear();&#10;&#10;            ClearGlowAndRestoreSprites();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>